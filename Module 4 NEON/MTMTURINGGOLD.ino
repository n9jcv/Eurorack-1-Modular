/* CLONE OF MUSIC THING MODULAR TURING MACHINE (MTMTM) MODULE by N9JCV
   Original idea from Neo Recasata - I then decided to write my own code with different functionality.
   Neo Recasata code is here;  https://github.com/NeoRecasata/RandomLoopingSequencer
   Thanks Neo Recasata for the inspiration!
   
   This is a Random Looping Sequencer very similar to the MTMTM
   Features as follows;
   *  Generates sequences of 2, 3, 4, 5, 6, 8, 12, 16 and 32 steps
   *  CV is Quantitized to 1V per octave
      The original code to Quantize the CV came from Hagiwo CV Gate Sequencer
      Hagiwo code here;  https://note.com/solder_state/n/n7c2809976698
      Hagiwo does say the code is open to the public.  Thanks Hagiwo!!
   *  A Octave setting is available to increase or decrease the range of possible random CV.
      Example: the full range of CV is 0 to 4095 - which is 61 distinct quantitized notes
      61 distinct steps would  5 octaves plus 1 half step
      With the pot for Octave, you can vary the between 1, 2, 3, 4 or 5 octaves
   *  Gate out is available - the Gate is generated by the Nano and this is not the same gate as the input gate  
      The Gate out can be set to always output for every step, or to output randomly
   *  Requires Gate in - sequencer is triggered on rising edge of Gate
   *  TM1637 module is used - has 4 digits
      - digits from left to right 0 1 2 3
      - digit 0 displays the current number of octaves selected for the range
      - digit 1 displays bars if the octave has been pushed up or down.  You can push the octave range up/down
        by a total 1 or 2 octaves depending on the number of octaves selected for range.
      - digit 2 and 3 display current step number
   *  Added the capability to move the selected octave range up/down by 1 or 2 octaves. By default if you reduce the total octave
      span from 5 to 4,3,2 or 1, the new reduced octave range will be self centered.  If 5 octaves are selected the cv values can          
      range between 0 and 4095.  Example: reducing the octave range to 2 octaves will constrain the cv values between 1227 and 2867, 
      thus centering the reduced range.  This is default behaviour. You can use the up/down buttons to move the range up or down 1 or 2
      octaves, but you can never exceed the 0 to 4095 range.  Thus if you select 1 octave you can move it up/down 1 or 2 octaves and the total
      cv span will be 1 octave.  If you select 2 octaves, you can move the range up/down 1 or 1.5 octaves.  If you select 3 octaves you can move
      the range up or down by 1 octave.  4 or 5 octaves can not be moved.
      Digit 1, second from the left - is used to display if you have moved the range with a - and a half square shape.
   *  
   *  MCP4725 is used for DAC - default address is used
   *  depending on what DAC you may need to change to 0x60 or 0x61 or 0x62
   *  DAC should be conneted like this to Arduino Nano
   *  NANO - DAC
   *  A4 - SDA
   *  A5 - SCL
*/

//download and install the following libraries before compiling
#include <Wire.h>
#include <Adafruit_MCP4725.h>
//https://github.com/avishorp/TM1637
#include <TM1637Display.h>

Adafruit_MCP4725 dac;

#define CVpot A0 //CV probability
#define octavepot A1 //Octave Pot
#define steppot A2 //step length
#define UPDOWN A7 //A7 USED FOR UP/DOWN POT
#define GATELED 2  //D2 for output GATE LED
#define GATEOUT 3  //D3 for ouput GATE
//D4 IS INPUT CLOCK
#define RANDGATESW 5  //D5 for Random Gate Switch
#define CLK 11  //D11 used for TM1637
#define DIO 12  //D12 used for TM1637

bool clk_in = 0;
bool old_clk_in = 0;
int sequence[32]; //step array

int count = 0; //number of steps
int randnum = 0;
int randnum2 = 0;
int steps = 4;
int octavesize = 5;
int cvval = 0;
int shift = 0;

//table used to Quantitize notes 1V per octave
const long cv_quant[61] = {
 0,  68, 137,  205,  273,  341,  410,  478,  546,  614,  683,  751,
 819,  887,  956,  1024, 1092, 1161, 1229, 1297, 1365, 1434, 1502, 1570,
 1638, 1707, 1775, 1843, 1911, 1980, 2048, 2116, 2185, 2253, 2321, 2389,
 2458, 2526, 2594, 2662, 2731, 2799, 2867, 2935, 3004, 3072, 3140, 3209,
 3277, 3345, 3413, 3482, 3550, 3618, 3686, 3755, 3823, 3891, 3959, 4028, 4095
};
//constants used for visual indication of what range notes will be generated in
const uint8_t ONEUP[] = {
 SEG_A
};
const uint8_t ONE5UP[] = {
 SEG_A | SEG_B | SEG_F
};
const uint8_t TWOUP[] = {
 SEG_A | SEG_G
};
const uint8_t ONEDOWN[] = {
 SEG_D
};
const uint8_t ONE5DOWN[] = {
 SEG_C | SEG_D | SEG_E
};
const uint8_t TWODOWN[] = {
 SEG_D | SEG_G
};
const uint8_t ZEROSEG[] = {
 SEG_G
};

TM1637Display display(CLK, DIO);

void setup() {
  display.clear();  //CLEAR TM1637
  display.setBrightness(1);
  //Serial.begin(115200); //UNCOMMENT FOR DEBUGGING
  pinMode(GATEOUT, OUTPUT);
  pinMode(GATELED, OUTPUT);
  //pin3 for clock in
  pinMode (3, INPUT);
  //begin DAC
  dac.begin(0x60);
  dac.setVoltage(0, false);
}

void loop() {
do {
  //read clock in
  clk_in = digitalRead(9);
  if (clk_in == 1 && old_clk_in == 0) {
      //dac.setVoltage(sequence[count], false); //Output CV
      stepsLength(); //determine steps length  SETS VALUE OF STEPS
      octavecheck(); //determine octave range for random CV   SETS VALUE OF OCTAVESIZE
      //CHECK FOR SHIFTING RANGE AFTER NUMBER OF OCTAVES IS SET 
      updowncheck();  //SETS VALUE OF SHIFT
      //Serial.println(shift);
      GetRandomCV(); //change voltage of step depending on the cv pot  SETS VALUE OF RANDNUM
      display.showNumberDec(count+1,false, 2, 2); //DISPLAY CURRENT STEP NUMBER RIGHT 2 POSITIONS
      display.showNumberDec(octavesize,false, 1, 0); //DISPLAY OCTAVE SETTING LEFT 1 POSITION
      dac.setVoltage(sequence[count], false); //Output CV
      //if RANDGATESW is HIGH then generate random gate
      //ELSE IF LOW then always generate a gate
      if (digitalRead(RANDGATESW) == LOW) {
          digitalWrite(GATELED, HIGH);
          digitalWrite(GATEOUT, HIGH);
      }
      else if (digitalRead(RANDGATESW) == HIGH) {
              RandomGate(); 
              if (randnum2 == 1) {
                  digitalWrite(GATELED, HIGH);
                  digitalWrite(GATEOUT, HIGH);
              }
           }
  old_clk_in = 1;
  }
  else if (clk_in == 0 && old_clk_in == 1){
           digitalWrite(GATELED, LOW);
           digitalWrite(GATEOUT, LOW);
           count ++;
           old_clk_in = 0;
       }
  } while (count < steps);
  count = 0;
}

static bool getRandomBool(int probability) {
  //returns true or false based on the probability
  //randVal starts from 20 to help keep the pot at 0 when it is fully ccw
  int randVal = random(20, 1023);
  return randVal <= probability;
}

static void GetRandomCV() {
  //generate a 12bit random number for CV
  //limit the random number to a range of octaves  1 to 5 octaves
  //centering in the range
  //example 5 octaves 0 to 4095
  // 1 octave is centered 1637 to 2457
  if (octavesize == 1) {
    randnum = random(1637, 2457);
  }
  else if (octavesize == 2){
    randnum = random(1227, 2867);
  }
  else if (octavesize == 3){
    randnum = random(817, 3277);
  }
    else if (octavesize == 4){
    randnum = random(407, 3687);
  }
    else if (octavesize == 5){
    randnum = random(0, 4096);
}
  //adjust range by shift amount 
  //1 octaves can move up/down 1 or 2 
  //2 octaves can move up/down 1 or 1.5
  //3 octaves can move up/down by 1
  //4 and 5 octaves can not move
  if ((shift == 1) and ((octavesize >= 1) and (octavesize <= 3))) {
      //shift up one octave
      display.setSegments(ONEUP, 1, 1);
      randnum = randnum + 817;  
  }
  else if ((shift == -1) and ((octavesize >= 1) and (octavesize <= 3))) {
      //shift down one octave
      display.setSegments(ONEDOWN, 1, 1);
      randnum = randnum - 817;  
  }
  else if ((shift == 2) and (octavesize == 2)) {
      //shift up 1.5 octaves
      display.setSegments(ONE5UP, 1, 1);
      randnum = randnum + 1225;
  }
  else if ((shift == 2) and (octavesize == 1)) {
      //shift up 2 octaves
      display.setSegments(TWOUP, 1, 1);
      randnum = randnum + 1635;  
  }
    else if ((shift == -2) and (octavesize == 2)) {
      //shift down 1.5 octaves
      display.setSegments(ONE5DOWN, 1, 1);
      randnum = randnum - 1225;
  }
  else if ((shift == -2) and (octavesize == 1)) {
      //shift down 2 octaves
      display.setSegments(TWODOWN, 1, 1);
      randnum = randnum - 1635;  
  }
  else if ((shift < 0) and (octavesize == 3)) {
      //shift down 2 octaves
      display.setSegments(ONEDOWN, 1, 1);
      randnum = randnum - 817;
  } 
  else if ((shift > 0) and (octavesize == 3)) {
      //shift down 2 octaves
      display.setSegments(ONEUP, 1, 1);
      randnum = randnum + 817;
  } 
  else {
    //NO SHIFT
      display.setSegments(ZEROSEG, 1, 1);
  }
  
  
  //randomly change values in the array depending on the potentiometer
  if (getRandomBool(analogRead(CVpot))) {
    //cv_quant IS A TABLE THAT HOLDS THE 1V PER OCTAVE QUANTITIZED VALUES
    //THE MAP SETS CVVAL TO ONE OF THOSE 61 VALUES
    cvval = map(randnum, 0, 4096, 0, 61);
    sequence[count] = cv_quant[cvval];
   }
}

static void RandomGate() {
  //generate random number from 0 to 1
  randnum2 = random(2);
}

static void stepsLength() {
  // Possible steps of 2, 3, 4, 5, 6, 8, 12, 16, 32
  int potvalue = analogRead(steppot);

  //Dividing the potentiometer to 9 different step lengths
  if (potvalue <= 113) {
    steps = 2;
  }
  else if ((potvalue >= 114) && (potvalue <= 227)) {
    steps = 3;
  }
  else if ((potvalue >= 228) && (potvalue <= 341)) {
    steps = 4;
  }
    else if ((potvalue >= 342) && (potvalue <= 455)) {
    steps = 5;
  }
    else if ((potvalue >= 456) && (potvalue <= 569)) {
    steps = 6;
  }
  else if ((potvalue >= 570) && (potvalue <= 683)) {
    steps = 8;
  }
    else if ((potvalue >= 684) && (potvalue <= 797)) {
    steps = 12;
  }
    else if ((potvalue >= 798) && (potvalue <= 911)) {
    steps = 16;
  }
    else if (potvalue >= 912) {
    steps = 32;
  }
}

static void octavecheck() {
  // Range of 1, 2, 3, 4 or 5 octaves
  int potvalue2 = analogRead(octavepot);

  //Dividing the POT into 5 for octave range 
  if (potvalue2 <= 204) {
    octavesize = 1;
  }
  else if ((potvalue2 >= 205) && (potvalue2 <= 408)) {
    octavesize = 2;
  }
  else if ((potvalue2 >= 409) && (potvalue2 <= 612)) {
    octavesize = 3;
  }
  else if ((potvalue2 >= 613) && (potvalue2 <= 816)) {
    octavesize = 4;
  }
  else if (potvalue2 >= 817){
    octavesize = 5;
  }
}

static void updowncheck() {
  // CAN PUSH OCTAVE RANGE UP/DOWN 1 OR 2 OCTAVES DEPENDING ON HOW MANY OCTAVES ARE SELECTED
  int potvalue3 = analogRead(UPDOWN);

  //Dividing the POT into 5 for shifting range 
  if (potvalue3 <= 204) {
    shift = -2;
  }
  else if ((potvalue3 >= 205) && (potvalue3 <= 408)) {
    shift = -1;
  }
    else if ((potvalue3 >= 409) && (potvalue3 <= 612)) {
    shift = 0;
  }
    else if ((potvalue3 >= 613) && (potvalue3 <= 816)) {
    shift = 1;
  }
    else if (potvalue3 >= 817){
    shift = 2;
  }
}
